/* syntaxop.c: Operators for opcodes generated by language syntax. */

#define _POSIX_SOURCE

#include <time.h>
#include <assert.h>
#include "config.h"
#include "x.tab.h"
#include "operator.h"
#include "execute.h"
#include "data.h"
#include "memory.h"
#include "ident.h"
#include "cache.h"
#include "cmstring.h"
#include "lookup.h"
#include "log.h"

void op_comment(void)
{
    /* Do nothing, just increment the program counter past the comment. */
    cur_frame->pc++;
    /* actually, increment the number of ticks left too, since comments
       really don't do anything */
    cur_frame->ticks++;
    /* decrement system tick */
    tick--;
}

void op_pop(void)
{
    pop(1);
}

void op_set_local(void)
{
    Data *var;

    /* Copy data in top of stack to variable. */
    var = &stack[cur_frame->var_start + cur_frame->opcodes[cur_frame->pc++]];
    data_discard(var);
    if (debugging & DEB_VAR) {
      write_log("set_local %D", &stack[stack_pos - 1]);
    }
    data_dup(var, &stack[stack_pos - 1]);
}

void op_set_obj_var(void)
{
    long ind, id, result;
    Data *val;

    ind = cur_frame->opcodes[cur_frame->pc++];
    id = object_get_ident(cur_frame->method->object, ind);
    val = &stack[stack_pos - 1];
    if (debugging & DEB_VAR) {
      write_log("set_object_var %D", val);
    }
    result = object_assign_var(cur_frame->object, cur_frame->method->object,
			       id, val);
    if (result == paramnf_id) {
	cthrow(paramnf_id, "No such parameter %I.", id);
    }
#if 0
    else
      pop(1); /* added from 12-1c */
#endif
}

void op_if(void)
{
    /* Jump if the condition is false. */
    if (!data_true(&stack[stack_pos - 1]))
	cur_frame->pc = cur_frame->opcodes[cur_frame->pc];
    else
	cur_frame->pc++;
    pop(1);
}

void op_else(void)
{
    cur_frame->pc = cur_frame->opcodes[cur_frame->pc];
}

void op_for_range(void)
{
    int var;
    Data *range;

    var = cur_frame->var_start + cur_frame->opcodes[cur_frame->pc + 1];
    range = &stack[stack_pos - 2];

    /* Make sure we have an integer range. */
    if (range[0].type != INTEGER) {
        type_error(&range[0], integer_id, "Lower range bound (%D) is not an integer.", &range[0]);
	return;
    }
    if (range[1].type != INTEGER) {
	type_error(&range[1], integer_id, "Upper range bound (%D) is not an integer.", &range[1]);
	return;
    }

    if (range[0].u.val > range[1].u.val) {
	/* We're finished; pop the range and jump to the end. */
	pop(2);
	cur_frame->pc = cur_frame->opcodes[cur_frame->pc];
    } else {
	/* Replace the index variable with the lower range bound, increment the
	 * range, and continue. */
	data_discard(&stack[var]);
	stack[var] = range[0];
	range[0].u.val++;
	cur_frame->pc += 2;
    }
}

void op_for_list(void)
{
    Data *counter;
    Data *domain;
    int var, len;
    List *pair;

    counter = &stack[stack_pos - 1];
    domain = &stack[stack_pos - 2];
    var = cur_frame->var_start + cur_frame->opcodes[cur_frame->pc + 1];

    /* Make sure we're iterating over a list.  We know the counter is okay. */
    if (domain->type != LIST && domain->type != DICT) {
        type_error(domain, type_id, "Domain (%D) is not a list or dictionary.", domain);
	return;
    }

    len = (domain->type == LIST) ? list_length(domain->u.list)
				 : dict_size(domain->u.dict);

    if (counter->u.val >= len) {
	/* We're finished; pop the list and counter and jump to the end. */
	pop(2);
	cur_frame->pc = cur_frame->opcodes[cur_frame->pc];
	return;
    }

    /* Replace the index variable with the next list element and increment
     * the counter. */
    data_discard(&stack[var]);
    if (domain->type == LIST) {
	data_dup(&stack[var], list_elem(domain->u.list, counter->u.val));
    } else {
	pair = dict_key_value_pair(domain->u.dict, counter->u.val);
	stack[var].type = LIST;
	stack[var].u.list = pair;
    }
    counter->u.val++;
    cur_frame->pc += 2;
}

void op_while(void)
{
    if (!data_true(&stack[stack_pos - 1])) {
	/* The condition expression is false.  Jump to the end of the loop. */
	cur_frame->pc = cur_frame->opcodes[cur_frame->pc];
    } else {
	/* The condition expression is true; continue. */
	cur_frame->pc += 2;
    }
    pop(1);
}

void op_switch(void)
{
    /* This opcode doesn't actually do anything; it just provides a place-
     * holder for a break statement. */
    cur_frame->pc++;
}

void op_case_value(void)
{
    /* There are two expression values on the stack: the controlling expression
     * for the switch statement, and the value for this case.  If they are
     * equal, pop them off the stack and jump to the body of this case.
     * Otherwise, just pop the value for this case, and go on. */
    if (data_cmp(&stack[stack_pos - 2], &stack[stack_pos - 1]) == 0) {
	pop(2);
	cur_frame->pc = cur_frame->opcodes[cur_frame->pc];
    } else {
	pop(1);
	cur_frame->pc++;
    }
}

void op_case_range(void)
{
    Data *switch_expr, *range;
    int is_match;

    switch_expr = &stack[stack_pos - 3];
    range = &stack[stack_pos - 2];

    /* Verify that range[0] and range[1] make a value type. */
    if (range[0].type != range[1].type) {
	cthrow(type_id, "%D and %D are not of the same type.",
	      &range[0], &range[1]);
	return;
    } else if (range[0].type != INTEGER && range[0].type != STRING) {
	cthrow(type_id, "%D and %D are not integers or strings.", &range[0],
	      &range[1]);
	return;
    }

    /* Decide if this is a match.  In order for it to be a match, switch_expr
     * must be of the same type as the range expressions, must be greater than
     * or equal to the lower bound of the range, and must be less than or equal
     * to the upper bound of the range. */
    is_match = (switch_expr->type == range[0].type);
    is_match = (is_match) && (data_cmp(switch_expr, &range[0]) >= 0);
    is_match = (is_match) && (data_cmp(switch_expr, &range[1]) <= 0);

    /* If it's a match, pop all three expressions and jump to the case body.
     * Otherwise, just pop the range and go on. */
    if (is_match) {
	pop(3);
	cur_frame->pc = cur_frame->opcodes[cur_frame->pc];
    } else {
	pop(2);
	cur_frame->pc++;
    }
}

void op_last_case_value(void)
{
    /* There are two expression values on the stack: the controlling expression
     * for the switch statement, and the value for this case.  If they are
     * equal, pop them off the stack and go on.  Otherwise, just pop the value
     * for this case, and jump to the next case. */
    if (data_cmp(&stack[stack_pos - 2], &stack[stack_pos - 1]) == 0) {
	pop(2);
	cur_frame->pc++;
    } else {
	pop(1);
	cur_frame->pc = cur_frame->opcodes[cur_frame->pc];
    }
}

void op_last_case_range(void)
{
    Data *switch_expr, *range;
    int is_match;

    switch_expr = &stack[stack_pos - 3];
    range = &stack[stack_pos - 2];

    /* Verify that range[0] and range[1] make a value type. */
    if (range[0].type != range[1].type) {
	cthrow(type_id, "%D and %D are not of the same type.",
	      &range[0], &range[1]);
	return;
    } else if (range[0].type != INTEGER && range[0].type != STRING) {
	cthrow(type_id, "%D and %D are not integers or strings.", &range[0],
	      &range[1]);
	return;
    }

    /* Decide if this is a match.  In order for it to be a match, switch_expr
     * must be of the same type as the range expressions, must be greater than
     * or equal to the lower bound of the range, and must be less than or equal
     * to the upper bound of the range. */
    is_match = (switch_expr->type == range[0].type);
    is_match = (is_match) && (data_cmp(switch_expr, &range[0]) >= 0);
    is_match = (is_match) && (data_cmp(switch_expr, &range[1]) <= 0);

    /* If it's a match, pop all three expressions and go on.  Otherwise, just
     * pop the range and jump to the next case. */
    if (is_match) {
	pop(3);
	cur_frame->pc++;
    } else {
	pop(2);
	cur_frame->pc = cur_frame->opcodes[cur_frame->pc];
    }
}

void op_end_case(void)
{
    /* Jump to end of switch statement. */
    cur_frame->pc = cur_frame->opcodes[cur_frame->pc];
}

void op_default(void)
{
    /* Pop the controlling switch expression. */
    pop(1);
}

void op_end(void)
{
    /* Jump to the beginning of the loop or condition expression. */
    cur_frame->pc = cur_frame->opcodes[cur_frame->pc];
}

void op_break(void)
{
    int n, op;

    /* Get loop instruction from argument. */
    n = cur_frame->opcodes[cur_frame->pc];

    /* If it's a for loop, pop the loop information on the stack (either a list
     * and an index, or two range bounds. */
    op = cur_frame->opcodes[n];
    if (op == FOR_LIST || op == FOR_RANGE)
	pop(2);

    /* Jump to the end of the loop. */
    cur_frame->pc = cur_frame->opcodes[n + 1];
}

void op_continue(void)
{
    /* Jump back to the beginning of the loop.  If it's a WHILE loop, jump back
     * to the beginning of the condition expression. */
    cur_frame->pc = cur_frame->opcodes[cur_frame->pc];
    if (cur_frame->opcodes[cur_frame->pc] == WHILE)
	cur_frame->pc = cur_frame->opcodes[cur_frame->pc + 2];
}

void op_return(void)
{
  long dbref = cur_frame->object->dbref;
  frame_return();

  if (cur_frame && cur_frame->specifiers && (cur_frame->specifiers->type == DBREF)) {
    propagate_error(0, methoderr_id);	/* you can't just `return' from an object error handler */
  } else if (cur_frame) {
    push_dbref(dbref);
  }
}

void op_return_expr(void)
{
    Data *val;

    /* Return, and push frame onto caller stack.  Transfers reference count to
     * caller stack.  Assumes (correctly) that there is space on the caller
     * stack. */
    val = &stack[--stack_pos];
    if (debugging & DEB_STACK) {
      write_log("PRE return_expr from %d %D", stack_pos, val);
    }
    frame_return();

    if (cur_frame) {
      if (debugging & DEB_CALL) {
	write_log("return_expr %D", val);
      }

      if (cur_frame->specifiers && (cur_frame->specifiers->type == DBREF)) {
	/* we're returning from an object error-handler */
	opcode_restart = 1;

	/* jam the object error-handler's result onto the stack as the offending value */
	data_discard(cur_frame->specifiers->u.obj.result);
	*(cur_frame->specifiers->u.obj.result) = *val;

	/* discard record of the object error-handler's existence */
	pop_error_action_specifier();
	pop_handler_info();
      } else {
	stack[stack_pos] = *val;
	stack_pos++;
      }
    } else {
      data_discard(val);
    }
}

void op_catch(void)
{
    Error_action_specifier *spec;

    /* Make a new error action specifier and push it onto the stack. */
    spec = EMALLOC(Error_action_specifier, 1);
    spec->type = CATCH;
    spec->stack_pos = stack_pos;
    spec->u.ccatch.handler = cur_frame->opcodes[cur_frame->pc++];
    spec->u.ccatch.error_list = cur_frame->opcodes[cur_frame->pc++];
    spec->next = cur_frame->specifiers;
    cur_frame->specifiers = spec;
    if (debugging & DEB_ERROR) {
      write_log("CATCH handler.  handler: %d next: %d",
		spec->u.ccatch.handler,
		spec->next
		);
    }
}

void op_catch_end(void)
{
    /* Pop the error action specifier for the catch statement, and jump past
     * the handler. */
    pop_error_action_specifier();
    cur_frame->pc = cur_frame->opcodes[cur_frame->pc];
}

void op_handler_end(void)
{
    pop_handler_info();
}

void op_zero(void)
{
    /* Push a zero. */
    push_int(0);
}

void op_one(void)
{
    /* Push a one. */
    push_int(1);
}

void op_integer(void)
{
    push_int(cur_frame->opcodes[cur_frame->pc++]);
}

void op_string(void)
{
    String *str;
    int ind = cur_frame->opcodes[cur_frame->pc++];

    str = object_get_string(cur_frame->method->object, ind);
    push_string(str);
}

void op_dbref(void)
{
    int id;

    id = cur_frame->opcodes[cur_frame->pc++];
    push_dbref(id);
}

void op_symbol(void)
{
    int ind, id;

    ind = cur_frame->opcodes[cur_frame->pc++];
    id = object_get_ident(cur_frame->method->object, ind);
    push_symbol(id);
}

void op_error(void)
{
    int ind, id;

    ind = cur_frame->opcodes[cur_frame->pc++];
    id = object_get_ident(cur_frame->method->object, ind);
    push_error(id);
}

void op_name(void)
{
    int ind, id;
    long dbref;

    ind = cur_frame->opcodes[cur_frame->pc++];
    id = object_get_ident(cur_frame->method->object, ind);
    if (lookup_retrieve_name(id, &dbref)) {
	push_dbref(dbref);
    } else {
	cthrow(namenf_id, "Can't find object name %I.", id);
    }
}

void op_get_local(void)
{
    int var;

    /* Push value of local variable on stack. */
    var = cur_frame->var_start + cur_frame->opcodes[cur_frame->pc++];
    if (debugging & DEB_VAR) {
      write_log("get_local %D -> %d", &stack[var], stack_pos);
    }
    push_data(&stack[var]);
}

void op_get_obj_var(void)
{
    long ind, id, result;
    Data val;

    /* Look for variable, and push it onto the stack if we find it. */
    ind = cur_frame->opcodes[cur_frame->pc++];
    id = object_get_ident(cur_frame->method->object, ind);
    result = object_retrieve_var(cur_frame->object, cur_frame->method->object,
				 id, &val);
    if (result == paramnf_id) {
	cthrow(paramnf_id, "No such parameter %I.", id);
    } else {
	if (debugging & DEB_VAR) {
	  write_log("get_obj_var %D", &val);
	}
	push_data(&val);
    }
}

void op_start_args(void)
{
    /* Resize argument stack if necessary. */
    if (arg_pos == arg_size) {
	arg_size = arg_size * 2 + ARG_STACK_MALLOC_DELTA;
	arg_starts = EREALLOC(arg_starts, int, arg_size);
    }

    if (debugging & DEB_STACK) {
	write_log("start_args[%d] <- %d ", arg_pos, stack_pos);
    }

    /* Push stack position onto argument start stack. */
    assert(arg_pos >= cur_frame->argpos_start);
    arg_starts[arg_pos++] = stack_pos;
}

void op_pass(void)
{
    int arg_start, result;

    arg_start = pop_args();

    /* Attempt to pass the message we're processing. */
    result = pass_message(arg_start, arg_start);

    if (result == numargs_id)
	cthrowstr(result, numargs_str);
    else if (result == methodnf_id)
	cthrow(result, "No next method found.");
    else if (result == maxdepth_id)
	cthrow(result, "Maximum call depth exceeded.");
}

/* This is very confusing. We have the message name as an arg as well as the 
   actual args, and in the case of a frob, we replace the message arg with the 
   frob rep. If the target isn't an object we send a message to 
   get_name(type(target))
*/
int op_expr_message(void)
{
  int arg_start, result, type;
  Data *target, *message_data, *rep = (Data*)0;
  long dbref, message;
  Frob *frob = (Frob*)0;

  arg_start = pop_args();

  /* work out the message symbol for send_message */
  message_data = &stack[arg_start - 1];		/* what we're sending */
  if (message_data->type != SYMBOL) {
    type_error(message_data, symbol_id, "Message (%D) is not a symbol.", message_data);
    return 1;
  }
  message = ident_dup(message_data->u.symbol);

  /* sort out the target dbref for send_message according to target's type */
  target = &stack[arg_start - 2];	/* where we're sending the message */
  type = target->type;
  if (type == DBREF) {
    dbref = target->u.dbref;
    rep = (Data *)0;
  } else if (type == FROB) {
    frob = target->u.frob;
    dbref = frob->cclass;
    rep = &frob->rep;		/* remember the frob's rep */
  } else if (!lookup_retrieve_name(data_type_id(target->type), &dbref)) {
    /* messages to all object types (JBB) */
    cthrow(objnf_id, "No object for data type %I", data_type_id(target->type));
    ident_discard(message);
    return 2;
  } else {
    rep = target;
  }

  /* Attempt to send the message. */
  ident_dup(message);
  result = send_message(dbref, message, rep, target - stack, arg_start);

  if (result == objnf_id) {
    /* ask the system object to map the target dbref to something useful */
    Object *obj = cache_retrieve(SYSTEM_DBREF);
    obj_handler(obj, target, objnf_id, "Target (#%l) not found.", dbref);
    cache_discard(obj);
    return 3;
  } else if (result == methodnf_id) {
    /* there's no point in using a non-existent .error() to find .error() */
    if (message == catch_id) {
      cthrow(methodnf_id, "Method %I not found.", message);

      return 4;
    }

    /* ask the object to map the message symbol to something useful */
    data_obj_handler(target, message_data, methodnf_id, "Method %I not found.", message);
    return 5;
  }

  /* not a recoverable error */

  if (result == numargs_id) {
    cthrowstr(result, numargs_str);
    return 6;
  } else if (result == maxdepth_id) {
    cthrow(result, "Maximum call depth exceeded.");
    return 7;
  }

  ident_discard(message);
  return 0;
}

void op_message(void)
{
  int arg_start, result, ind, type;
  Data *target, *rep = (Data*)0;
  long message, dbref;
  Frob *frob = (Frob *)0;

  if (opcode_restart) {
    /* this opcode is being restarted after an object error handler.
       Because op_message gets its method from method code, it's been necessary
       to convert its stackframe to apre an op_expr_message, before calling the
       handler (because a handler can't modify method code.
       op_message isn't simply interpreted as a specialisation of op_expr_message
       because the additional overhead is unwarranted except in the restart case.
       We now proceed with the opcode.
       */
    op_expr_message();
    return;
  }

  arg_start = pop_args();

  /* work out the message symbol for send_message */
  ind = cur_frame->opcodes[cur_frame->pc++];
  message = object_get_ident(cur_frame->method->object, ind);
  if (debugging & DEB_MESSAGE) {
    write_log("message: %s[%d]", ident_name(message), ind);
  }

  /* sort out the target dbref for send_message according to target's type */
  target = &stack[arg_start - 1];	/* target of method invocation */
  type = target->type;
  if (type == DBREF) {
    dbref = target->u.dbref;
    rep = (Data *)0;
  } else if (type == FROB) {
    /* Convert the frob to its rep and pass as first argument. */
    frob = target->u.frob;
    dbref = frob->cclass;
    rep = &frob->rep;
  } else if (!lookup_retrieve_name(data_type_id(target->type), &dbref)) {
    /* messages to all object types (JBB) */
    cthrow(objnf_id, "No object for data type %I", data_type_id(target->type));
    return;
  } else {
    rep = target;
  }

  /* Attempt to send the message. */
  ident_dup(message);
  result = send_message(dbref, message, rep, target - stack, arg_start);
  
  if (result == objnf_id || result == methodnf_id) {
    /* recoverable error */
    /* in recovering from the error, we must restart this as an op_expr_message,
       so the stack frame has to be brought into op_expr_message conformance.
       This entails taking the message out of the opcodes and onto the stack.
       */
    check_stack(1);	/* one extra argument to be pushed - message */

    /* splice message into stack above target to give an op_expr_message frame */
    memmove(target+2, target+1, sizeof(Data) * (stack_pos - arg_start));
    (target+1)->type = SYMBOL;
    (target+1)->u.symbol = message;

    /* adjust the start of args and end of stack to reflect the new push */
    stack_pos++;
    arg_start++;

    if (result == objnf_id) {
      Object *obj;
      /* ask the system object to map the target dbref to something useful */
      obj = cache_retrieve(SYSTEM_DBREF);
      obj_handler(obj, target, objnf_id, "Target (#%l) not found.", dbref);
      cache_discard(obj);
      return;
    } else if (result == methodnf_id) {
      if (message == catch_id) {
	/* there's no point in using a non-existent .error() to find .error() */
	cthrow(methodnf_id, "Method %I not found.", message);

	return;
      }
      /* ask the object to map the message symbol to something useful */
      data_obj_handler(target, target+1, methodnf_id, "Method %I not found.", message);
      return;
    }
  }

  /* not a recoverable error */

  if (result == numargs_id) {
    cthrowstr(result, numargs_str);
  } else if (result == maxdepth_id) {
    cthrow(result, "Maximum call depth exceeded.");
  }

  ident_discard(message);
}

void op_list(void)
{
    int start, len;
    List *list;
    Data *d;

    start = pop_args();
    len = stack_pos - start;

    /* Move the elements into a list. */
    list = list_new(len);
    d = list_empty_spaces(list, len);
    MEMCPY(d, &stack[start], len);
    stack_pos = start;

    /* Push the list onto the stack where elements began. */
    push_list(list);
    list_discard(list);
}

void op_dict(void)
{
    int start, len;
    List *list;
    Data *d;
    Dict *dict;

    start = pop_args();
    len = stack_pos - start;

    /* Move the elements into a list. */
    list = list_new(len);
    d = list_empty_spaces(list, len);
    MEMCPY(d, &stack[start], len);
    stack_pos = start;

    /* Construct a dictionary from the list. */
    dict = dict_from_slices(list);
    list_discard(list);
    if (!dict) {
	cthrow(type_id, "Arguments were not all two-element lists.");
    } else {
	push_dict(dict);
	dict_discard(dict);
    }
}

void op_buffer(void)
{
    int start, len, i;
    Buffer *buf;

    start = pop_args();
    len = stack_pos - start;
    for (i = 0; i < len; i++) {
	if (stack[start + i].type != INTEGER) {
	    cthrow(type_id, "Element %d (%D) is not an integer.", i + 1,
		  &stack[start + i]);
	    return;
	}
    }
    buf = buffer_new(len);
    for (i = 0; i < len; i++)
	buf->s[i] = ((unsigned long) stack[start + i].u.val) % (1 << 8);
    stack_pos = start;
    push_buffer(buf);
    buffer_discard(buf);
}

void op_frob(void)
{
    Data *cclass, *rep;

    cclass = &stack[stack_pos - 2];
    rep = &stack[stack_pos - 1];
    if (cclass->type != DBREF) {
	type_error(cclass, dbref_id, "Class (%D) is not a dbref.", cclass);
	return;
    } else {
      Dbref dbref = cclass->u.dbref;
      cclass->type = FROB;
      cclass->u.frob = TMALLOC(Frob, 1);
      cclass->u.frob->cclass = dbref;
      data_dup(&cclass->u.frob->rep, rep);
      pop(1);
    }
}

void op_index(void)
{
    Data *d, *ind, element;
    int i, len;
    String *str;

    d = &stack[stack_pos - 2];
    ind = &stack[stack_pos - 1];
    if (d->type != LIST && d->type != STRING && d->type != DICT) {
	type_error(d, type_id, "Array (%D) is not a list, string, or dictionary.", d);
	return;
    } else if (d->type != DICT && ind->type != INTEGER) {
	cthrow(type_id, "Offset (%D) is not an integer.", ind);
	return;
    } 

    if (d->type == DICT) {
	/* Get the value corresponding to a key. */
	if (dict_find(d->u.dict, ind, &element) == keynf_id) {
	    cthrow(keynf_id, "Key (%D) is not in the dictionary.", ind);
	} else {
	    pop(1);
	    data_discard(d);
	    *d = element;
	}
	return;
    }

    /* It's not a dictionary.  Make sure ind is within bounds. */
    len = (d->type == LIST) ? list_length(d->u.list) : string_length(d->u.str);
    i = ind->u.val - 1;
    if (check_index(i, len, d)) {
      /* Replace d with the element of d numbered by ind. */
      if (d->type == LIST) {
	data_dup(&element, list_elem(d->u.list, i));
	pop(2);
	stack[stack_pos] = element;
	stack_pos++;
      } else {
	str = string_from_chars(string_chars(d->u.str) + i, 1);
	pop(2);
	push_string(str);
	string_discard(str);
      }
    }
}

void op_and(void)
{
    /* Short-circuit if left side is false; otherwise discard. */
    if (!data_true(&stack[stack_pos - 1])) {
	cur_frame->pc = cur_frame->opcodes[cur_frame->pc];
    } else {
	cur_frame->pc++;
	pop(1);
    }
}

void op_or(void)
{
    /* Short-circuit if left side is true; otherwise discard. */
    if (data_true(&stack[stack_pos - 1])) {
	cur_frame->pc = cur_frame->opcodes[cur_frame->pc];
    } else {
	cur_frame->pc++;
	pop(1);
    }
}

void op_splice(void)
{
    int i;
    List *list;
    Data *d;

    if (stack[stack_pos - 1].type != LIST) {
        type_error(stack + stack_pos - 1, list_id, "%D is not a list.", &stack[stack_pos - 1]);
	return;
    }
    list = stack[stack_pos - 1].u.list;

    /* Splice the list onto the stack, overwriting the list. */
    check_stack(list_length(list) - 1);
    for (d = list_first(list), i=0; d; d = list_next(list, d), i++)
	data_dup(&stack[stack_pos - 1 + i], d);
    stack_pos += list_length(list) - 1;

    list_discard(list);
}

void op_critical(void)
{
    Error_action_specifier *spec;

    /* Make an error action specifier for the critical expression, and push it
     * onto the stack. */
    spec = EMALLOC(Error_action_specifier, 1);
    spec->type = CRITICAL;
    spec->stack_pos = stack_pos;
    spec->u.critical.end = cur_frame->opcodes[cur_frame->pc++];
    spec->next = cur_frame->specifiers;
    cur_frame->specifiers = spec;
    if (debugging & DEB_ERROR) {
      write_log("CRITICAL handler.  critical_end: %d next: %d",
		spec->u.critical.end,
		spec->next
		);
    }
}

void op_critical_end(void)
{
    pop_error_action_specifier();
}

void op_propagate(void)
{
    Error_action_specifier *spec;

    /* Make an error action specifier for the critical expression, and push it
     * onto the stack. */
    spec = EMALLOC(Error_action_specifier, 1);
    spec->type = PROPAGATE;
    spec->stack_pos = stack_pos;
    spec->u.propagate.end = cur_frame->opcodes[cur_frame->pc++];
    spec->next = cur_frame->specifiers;
    cur_frame->specifiers = spec;
    if (debugging & DEB_ERROR) {
      write_log("PROPAGATE handler.  propagate.end: %d next: %d",
		spec->u.propagate.end,
		spec->next
		);
    }
}

void op_propagate_end(void)
{
    pop_error_action_specifier();
}

